<!DOCTYPE html>
<html>
  <head>
    <title>omatz - Cartesian product of infinite sequences</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="stylesheet" href="/sp.css">
  </head>
  <body>
    <header>
      <h3><a href="/">omatz</a></h3>
      <nav>
        <a href="/">About</a>
        <a href="/posts/">Posts</a>
      </nav>
    </header>

    <main>
<h1>Cartesian product of infinite sequences</h1>

<p>While practicing for this year&rsquo;s <a href="https://adventofcode.com/">Advent Of
Code</a>, I wondered how to to compute the
cartesian product of infinite sequences. I tried to come up with a
solution myself, and as a solution matured in my head, I wanted to
put it both in words &amp; in code.</p>

<h2>The problem with regular cartesian product methods</h2>

<p>By generating a cartesian product lexicographically, you will get
&ldquo;stuck&rdquo; iterating through an infinite sequence, never picking any
other element from the other sequences. To illustrate, here&rsquo;s how
you would generate a cartesian product in lexicographic order :</p>

<pre><code>Let N be the set of natural numbers

for x in N
    for y in N
        for z in N
            yield (x, y, z)
</code></pre>

<p>In this case, we would never leave the inner-most loop, leaving x
and y never changing value.</p>

<h2>And now, to the solution</h2>

<p>Let the <code>rank</code> of a tuple be the maximum index of any of its element in
its originating sequence. Using our last example with natural numbers :</p>

<pre><code>x âˆˆ N x N x N
x = (10, 30, 20)
rank( x ) = 30
</code></pre>

<p>because the second element is the 30th element of the natural numbers.</p>

<p>The idea consists of computing elements of the cartesian product
in increasing order of rank. To find elements of a given rank <code>n</code>,
we can &ldquo;pin&rdquo; some sequences to their nth element, and limit other sequences
to their <code>n - 1</code> first elements. Then a lexicographic cartesian product
function is used to generate a subset of the rank. To cover the entire
rank, we need to do this for all combinations of &ldquo;pinned&rdquo;
positions, which we can generate using, you guessed it, a lexicographic
cartesian product function.</p>

<p>I thought it was kind of clever (in a that-code-is-unreadable way,
I guess).</p>

<h2>Show me the code, please</h2>

<p>Here&rsquo;s a commented implementation in clojure that you can try for
yourself : <a href="https://github.com/matzoliv/cartesian-product-inf/blob/main/src/cartesian_product_inf/core.clj">https://github.com/matzoliv/cartesian-product-inf/blob/main/src/cartesian_product_inf/core.clj</a></p>

<p>Here&rsquo;s how it looks like when applied to 3 sets of natural integers</p>

<pre><code class="clojure">&gt; (take 15 (cartesian-product-by-rank (rest (range)) (rest (range)) (rest (range))))
((1 1 1)
 (1 1 2)
 (1 2 1)
 (1 2 2)
 (2 1 1)
 (2 1 2)
 (2 2 1)
 (2 2 2)
 (1 1 3)
 (1 2 3)
 (2 1 3)
 (2 2 3)
 (1 3 1)
 (1 3 2)
 (2 3 1))
</code></pre>
    </main>
  </body>
</html>
